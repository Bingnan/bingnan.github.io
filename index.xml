<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bingnan blog</title>
    <link>http://bingnan.github.io/</link>
    <description>Recent content on bingnan blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 20 Nov 2016 10:49:52 +0800</lastBuildDate>
    <atom:link href="http://bingnan.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何创建nginx rtmp module的xcode工程</title>
      <link>http://bingnan.github.io/blog/2016/11/20/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAnginx-rtmp-module%E7%9A%84xcode%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Sun, 20 Nov 2016 10:49:52 +0800</pubDate>
      
      <guid>http://bingnan.github.io/blog/2016/11/20/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAnginx-rtmp-module%E7%9A%84xcode%E5%B7%A5%E7%A8%8B/</guid>
      <description>

&lt;h4 id=&#34;适用于macos-sierra新系统-感谢-https-github-com-akagi201-ffmpeg-xcode:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;适用于MacOS Sierra新系统，感谢 &lt;a href=&#34;https://github.com/Akagi201/ffmpeg-xcode&#34;&gt;https://github.com/Akagi201/ffmpeg-xcode&lt;/a&gt;&lt;/h4&gt;

&lt;h2 id=&#34;step1-编译nginx-1-8-1和nginx-rtmp-module模块:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step1 编译nginx-1.8.1和nginx-rtmp-module模块&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;找一个位置放置好nginx和nginx-rtmp-module的代码，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx-1.8.1
├── CHANGES
├── CHANGES.ru
├── LICENSE
├── Makefile
├── README
├── auto
├── conf
├── configure
├── contrib
├── html
├── man
├── nginx-rtmp-module
├── objs
└── src
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入nginx目录，执行configure命令，configure命令可能会因不同机器而不同，可以参考在我的mac上的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --prefix=/Users/duanbingnan_mt/nginx --add-module=./nginx-rtmp-module --with-debug --with-http_ssl_module --with-cc-opt=&amp;quot;-I/usr/local/Cellar/pcre/8.37/include -I/usr/local/opt/openssl/include&amp;quot; --with-ld-opt=&amp;quot;-L/usr/local/Cellar/pcre/8.37/lib -L/usr/local/opt/openssl/lib&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;开始编译 make -j4&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step2-新建一个空的xcode目录:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step2 新建一个空的xcode目录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建一个空的xcode项目
&lt;img src=&#34;http://bingnan.github.io/img/1/create_empty_project.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;http://bingnan.github.io/img/1/create_empty_project1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后选一个地方保存xcode的工程文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step3-将nginx源码-包含nginx-rtmp-module-拖拽到xcode项目中:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step3 将nginx源码(包含nginx-rtmp-module)拖拽到xcode项目中&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将nginx整个源码目录拖拽进xcode项目中的nginx-rtmp-xcode目录下
&lt;img src=&#34;http://bingnan.github.io/img/1/add_src_to_xcode.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下一步，这里一定不要勾选&amp;rdquo;Create external build system project&amp;rdquo;
&lt;img src=&#34;http://bingnan.github.io/img/1/add_src_to_xcode1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下一步，这里一定要勾选&amp;rdquo;Add to target&amp;rdquo;下的&amp;rdquo;nginx-rtmp-xcode&amp;rdquo;，否则看代码时无法跳转，写代码时也没有提示
&lt;img src=&#34;http://bingnan.github.io/img/1/add_src_to_xcode2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step4-添加一个target:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step4 添加一个target&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;File -&amp;gt; New -&amp;gt; Target -&amp;gt; Cross Platform -&amp;gt; other -&amp;gt; External Build System
&lt;img src=&#34;http://bingnan.github.io/img/1/create_target.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;target命名为nginx-rtmp-make,确认你的make工具在/usr/bin/make路径下
&lt;img src=&#34;http://bingnan.github.io/img/1/create_target1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;target切换到nginx-rtmp-make
&lt;img src=&#34;http://bingnan.github.io/img/1/create_target2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step5-修改nginx-rtmp-make的源码路径:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step5 修改nginx-rtmp-make的源码路径&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开nginx-rtmp-xcode工程配置页面，选择nginx-rtmp-make这个target,在&amp;rdquo;info&amp;rdquo;中输入nginx源码的路径：
&lt;img src=&#34;http://bingnan.github.io/img/1/change_src_path.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;step6-修改编译参数:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step6 修改编译参数&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用鼠标点击xode界面左上角的切换target按钮，选择&amp;rdquo;Edit Scheme&amp;rdquo;, 在&amp;rdquo;Run&amp;rdquo;标签页中的&amp;rdquo;Info&amp;rdquo;下选择第一步编译出来的Nginx可执行二进制文件路径
&lt;img src=&#34;http://bingnan.github.io/img/1/make_args.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Arguments下可以添加启动参数，对于nginx来说，可以指定Nginx.conf的路径
&lt;img src=&#34;http://bingnan.github.io/img/1/make_args1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;step7-调试:15916fd7d00a8a932116d30de5a0ef13&#34;&gt;step7 调试&lt;/h2&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改nginx.conf,加上下面几个配置项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;master_process off;
worker_processes 1;
daemon off;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下断点，调试
&lt;img src=&#34;http://bingnan.github.io/img/1/debug.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>nginx rtmp module directives翻译和注释</title>
      <link>http://bingnan.github.io/blog/2015/12/22/nginx-rtmp-module-directives%E7%BF%BB%E8%AF%91%E5%92%8C%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Tue, 22 Dec 2015 19:58:06 +0800</pubDate>
      
      <guid>http://bingnan.github.io/blog/2015/12/22/nginx-rtmp-module-directives%E7%BF%BB%E8%AF%91%E5%92%8C%E6%B3%A8%E9%87%8A/</guid>
      <description>

&lt;p&gt;这个我称之为 『段批』 nginx-rtmp-module使用指南&lt;/p&gt;

&lt;p&gt;原文在 &lt;a href=&#34;https://github.com/arut/nginx-rtmp-module/wiki/Directives&#34;&gt;nginx-rtmp-module Directives&lt;/a&gt; 是最后修改于2014年12月17日的版本。&lt;/p&gt;

&lt;p&gt;网上也有几个翻译的版本，但都比较老了，我这个主要参考了&lt;a href=&#34;http://blog.csdn.net/defonds/article/details/9274479&#34;&gt;这篇&lt;/a&gt; 还有闯闯自己翻译珍藏的版本。&lt;/p&gt;

&lt;p&gt;中英文对照形式的，有的解释其实看英文更好理解，所以这样编排。&lt;/p&gt;

&lt;p&gt;最主要的特色是在部分指令后加入了&lt;strong&gt;提示&lt;/strong&gt;，把我们在最近几个月里使用nginx-rtmp-module的方法，或是遇到的问题以及解决方法记录了一下。&lt;/p&gt;

&lt;p&gt;Ready? GO!&lt;/p&gt;

&lt;h1 id=&#34;table-of-contents:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Table of Contents&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#core&#34;&gt;Core&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp&#34;&gt;rtmp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#server&#34;&gt;server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#listen&#34;&gt;listen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#application&#34;&gt;application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#timeout&#34;&gt;timeout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ping&#34;&gt;ping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ping_timeout&#34;&gt;ping_timeout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#max_streams&#34;&gt;max_streams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ack_window&#34;&gt;ack_window&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chunk_size&#34;&gt;chunk_size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#max_queue&#34;&gt;max_queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#max_message&#34;&gt;max_message&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#buflen&#34;&gt;buflen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#out_queue&#34;&gt;out_queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#out_cork&#34;&gt;out_cork&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#access&#34;&gt;Access&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#allow&#34;&gt;allow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deny&#34;&gt;deny&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec&#34;&gt;Exec&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#exec_push&#34;&gt;exec_push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_pull&#34;&gt;exec_pull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec&#34;&gt;exec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_options&#34;&gt;exec_options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_static&#34;&gt;exec_static&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_kill_signal&#34;&gt;exec_kill_signal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#respawn&#34;&gt;respawn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#respawn_timeout&#34;&gt;respawn_timeout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_publish&#34;&gt;exec_publish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_play&#34;&gt;exec_play&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_play_done&#34;&gt;exec_play_done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_publish_done&#34;&gt;exec_publish_done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exec_record_done&#34;&gt;exec_record_done&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#live&#34;&gt;Live&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#live&#34;&gt;live&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#meta&#34;&gt;meta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#interleave&#34;&gt;interleave&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#wait_key&#34;&gt;wait_key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#wait_video&#34;&gt;wait_video&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#publish_notify&#34;&gt;publish_notify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#drop_idle_publisher&#34;&gt;drop_idle_publisher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sync&#34;&gt;sync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#play_restart&#34;&gt;play_restart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#idle_streams&#34;&gt;idle_streams&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record&#34;&gt;Record&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#record&#34;&gt;record&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_path&#34;&gt;record_path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_suffix&#34;&gt;record_suffix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_unique&#34;&gt;record_unique&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_append&#34;&gt;record_append&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_lock&#34;&gt;record_lock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_max_size&#34;&gt;record_max_size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_max_frames&#34;&gt;record_max_frames&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_interval&#34;&gt;record_interval&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#recorder&#34;&gt;recorder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#record_notify&#34;&gt;record_notify&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#video-on-demand&#34;&gt;Video on demand&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#play&#34;&gt;play&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#play_temp_path&#34;&gt;play_temp_path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#play_local_path&#34;&gt;play_local_path&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#relay&#34;&gt;Relay&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pull&#34;&gt;pull&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#push&#34;&gt;push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#push_reconnect&#34;&gt;push_reconnect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#session_relay&#34;&gt;session_relay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notify&#34;&gt;Notify&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#on_connect&#34;&gt;on_connect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_play&#34;&gt;on_play&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_publish&#34;&gt;on_publish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_done&#34;&gt;on_done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_play_done&#34;&gt;on_play_done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_publish_done&#34;&gt;on_publish_done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_record_done&#34;&gt;on_record_done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#on_update&#34;&gt;on_update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notify_update_timeout&#34;&gt;notify_update_timeout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notify_update_strict&#34;&gt;notify_update_strict&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notify_relay_redirect&#34;&gt;notify_relay_redirect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notify_method&#34;&gt;notify_method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls&#34;&gt;HLS&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hls&#34;&gt;hls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_path&#34;&gt;hls_path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_fragment&#34;&gt;hls_fragment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_playlist_length&#34;&gt;hls_playlist_length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_sync&#34;&gt;hls_sync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_continuous&#34;&gt;hls_continuous&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_nested&#34;&gt;hls_nested&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_base_url&#34;&gt;hls_base_url&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_cleanup&#34;&gt;hls_cleanup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_fragment_naming&#34;&gt;hls_fragment_naming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_fragment_naming_granularity&#34;&gt;hls_fragment_naming_granularity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_fragment_slicing&#34;&gt;hls_fragment_slicing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_variant&#34;&gt;hls_variant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_type&#34;&gt;hls_type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_keys&#34;&gt;hls_keys&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_key_path&#34;&gt;hls_key_path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_key_url&#34;&gt;hls_key_url&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls_fragments_per_key&#34;&gt;hls_fragments_per_key&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpeg-dash&#34;&gt;MPEG-DASH&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dash&#34;&gt;dash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dash_path&#34;&gt;dash_path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dash_fragment&#34;&gt;dash_fragment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dash_playlist_length&#34;&gt;dash_playlist_length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dash_nested&#34;&gt;dash_nested&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dash_cleanup&#34;&gt;dash_cleanup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#access-log&#34;&gt;Access log&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#access_log&#34;&gt;access_log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#log_format&#34;&gt;log_format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#limits&#34;&gt;Limits&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#max_connections&#34;&gt;max_connections&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#statistics&#34;&gt;Statistics&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp_stat&#34;&gt;rtmp_stat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp_stat_stylesheet&#34;&gt;rtmp_stat_stylesheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multi-worker-live-streaming&#34;&gt;Multi-worker live streaming&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp_auto_push&#34;&gt;rtmp_auto_push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp_auto_push_reconnect&#34;&gt;rtmp_auto_push_reconnect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp_socket_dir&#34;&gt;rtmp_socket_dir&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#control&#34;&gt;Control&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rtmp_control&#34;&gt;rtmp_control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;core:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Core&lt;/h2&gt;

&lt;h4 id=&#34;rtmp:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;rtmp { ... }&lt;/code&gt;&lt;br /&gt;
context: root&lt;br /&gt;
The block which holds all RTMP settings&lt;br /&gt;
此块包含所有RTMP设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这是必须用到的参数&lt;/p&gt;

&lt;h4 id=&#34;server:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;server&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;server { ... }&lt;/code&gt;&lt;br /&gt;
context: rtmp&lt;br /&gt;
Declares RTMP server instance&lt;br /&gt;
声明RTMP服务器实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rtmp {
  server {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这是必须用到的参数&lt;/p&gt;

&lt;h4 id=&#34;listen:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;listen&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;listen (addr[:port]|port|unix:path) [bind]  [ipv6only=on|off] [so_keepalive=on|off|keepidle:keepintvl:keepcnt|proxy_protocol]&lt;/code&gt;&lt;br /&gt;
context: server&lt;/p&gt;

&lt;p&gt;Adds listening socket to NGINX for accepting RTMP connections&lt;br /&gt;
设置RTMP服务的监听端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 1935;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这是必须用到的参数，一般RTMP服务器监听1935端口，但也可以修改&lt;/p&gt;

&lt;h4 id=&#34;application:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;application&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;application name { ... }&lt;/code&gt;&lt;br /&gt;
context: server&lt;/p&gt;

&lt;p&gt;Creates RTMP application. Unlike http location application name cannot
be a pattern.&lt;/p&gt;

&lt;p&gt;建立RTMP应用,与HTTP的location不同,不能是一个匹配模式(pattern),我理解就是必须是一个固定的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
    listen 1935;
    application myapp {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这是必须用到的参数，application是一个重要的参数，每个application{}块都是一个比较独立的配置块，一个server{}块中可以配置多个application{}块，每个可配成不同的行为，同时这个application的名字就是我们用推流工具往rtmp服务器上推流时用到的appid:&lt;/p&gt;

&lt;p&gt;例如：  rtmp://localhost:1935/appid/streamid&lt;/p&gt;

&lt;p&gt;其中appid就是你想往哪个application上推就填写哪个appid。&lt;br /&gt;
streamid一般是随便填，只要推流时和播放时一致就行。&lt;/p&gt;

&lt;h4 id=&#34;timeout:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;timeout&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;timeout value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;Socket timeout. This value is primarily used for writing. Most of time RTMP
module does not expect any activity on all sockets except for publisher socket.
If you want broken socket to get quickly disconnected use active tools like
keepalive or RTMP ping. Default is 1 minute.&lt;/p&gt;

&lt;p&gt;Socket超时,默认值是1分钟。主要用于写入。多数时候,除了RTMP的发布连接所使用的socket,RTMP module并不希望在其他的socket上有活动连接。如果希望快速断开错误连接,使用keepalive或RTMP ping。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;timeout 60s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;ping:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;ping&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;ping value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;RTMP ping interval. Zero turns ping off. RTMP ping is a protocol feature for
active connection check. A special packet is sent to remote peer and a reply
is expected within a timeout specified with ping_timeout directive. If ping
reply is not received within this time then connection is closed. Default
value for ping is 1 minute. Default ping timeout is 30 seconds.&lt;/p&gt;

&lt;p&gt;RTMP ping间隔。设置为0时，表示关闭ping。RTMP ping是一个用于检查活动连接的协议功能，发送一个特殊的包到远程连接，然后在ping_timeout指令指定的时间内期待一个回复。如果在这个时间里没有收到ping回复，连接断开。默认值是30秒。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ping 3m;
ping_timeout 30s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;ping-timeout:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;ping_timeout&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;ping_timeout value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;See ping description above.&lt;br /&gt;
见上&lt;/p&gt;

&lt;h4 id=&#34;max-streams:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;max_streams&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;max_streams value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;Sets maximum number of RTMP streams. Data streams are multiplexed into
a single data stream. Different channels are used for sending commands,
audio, video etc. Default value is 32 which is usually ok for many cases.&lt;/p&gt;

&lt;p&gt;设置RTMP流的最大数目。数据流被复用到一个单一的数据流里。不同的频道用于发送命令、音频、视频等。 默认32,通常够用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;max_streams 32;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;ack-window:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;ack_window&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;ack_window value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;Sets RTMP acknowledge window size. It&amp;rsquo;s the number of bytes received after
which peer should send acknowledge packet to remote side. Default value is
5000000.&lt;/p&gt;

&lt;p&gt;设置RTMP确认的Window size, Window size就是一次发送数据,接收方可不作应答的最大长度。默认 5000000。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ack_window 5000000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;chunk-size:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;chunk_size&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;chunk_size value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;Maximum chunk size for stream multiplexing. Default is 4096. The bigger
this value the lower CPU overhead. This value cannot be less than 128.&lt;/p&gt;

&lt;p&gt;RTMP协议中chunk的大小。默认值为4096。这个值设置的越大CPU负载就越小。这个值不能低于128。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chunk_size 4096;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;max-queue:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;max_queue&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 无解释&lt;/p&gt;

&lt;h4 id=&#34;max-message:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;max_message&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;max_queue value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;Maximum size of input data message. All input data comes split into
messages (and further in chunks). A partial message is kept in memory while
waiting for it to complete. In theory incoming message can be
very large which can be a problem for server stability. Default value
1M is enough for many cases.&lt;/p&gt;

&lt;p&gt;输入数据报文最大尺寸。所有输入数据会被分割成报文（然后进一步分割为块）。报文在处理结束之前会放在内存里。理论上讲，接收到的报文很大的话对于服务器的稳定性可能会有影响。默认值 1M 对于大多数情况就足够了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;max_message 1M;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h3 id=&#34;buflen:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;buflen&lt;/h3&gt;

&lt;p&gt;syntax: &lt;code&gt;buflen time&lt;/code&gt;&lt;br /&gt;
context: rtmp, server&lt;/p&gt;

&lt;p&gt;Sets default buffer length. Usually client sends RTMP &lt;code&gt;set_buflen&lt;/code&gt; command
before playing and resets this setting. Default is &lt;code&gt;1000 ms&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;缓冲区时长,默认1s。通常客户端在播放前,发送 RTMP set_buflen命令重设此值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buflen 5s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 为了减小延迟，我们可以尝试适当减小这个值，比如设成200ms。&lt;/p&gt;

&lt;h4 id=&#34;out-queue:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;out_queue&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 无解释&lt;/p&gt;

&lt;h4 id=&#34;out-cork:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;out_cork&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 无解释&lt;/p&gt;

&lt;h2 id=&#34;access:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Access&lt;/h2&gt;

&lt;h4 id=&#34;allow:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;allow&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;allow [play|publish] address|subnet|all&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Allow publishing/playing from addresses specified or from all addresses.
Allow/deny directives are checked in order of appearance.&lt;/p&gt;

&lt;p&gt;设置允许发布或播放的地址或地址范围。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allow publish 127.0.0.1;
deny publish all;
allow play 192.168.0.0/24;
deny play all;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有设置这个值&lt;/p&gt;

&lt;h4 id=&#34;deny:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;deny&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;deny [play|publish] address|subnet|all&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;See allow for description.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有设置这个值&lt;/p&gt;

&lt;h2 id=&#34;exec:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Exec&lt;/h2&gt;

&lt;h4 id=&#34;exec-push:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_push&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_push command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed on
every stream published. When publishing stops the process
is terminated. Full path to binary should be specified as the
first argument. There are no assumptions about what this process should
do. However this feature is useful with ffmpeg for stream
transcoding. FFmpeg is supposed to connect to nginx-rtmp as a client
and output transcoded stream back to nginx-rtmp as publisher. Substitutions
of form $var/${var} can be used within command line:&lt;/p&gt;

&lt;p&gt;当每个流发布时执行提前指定的带参数的外部命令。当这个流发布停止时这个外部命令的进程也随之终止。注意外部命令的第一个参数要指定绝对路径（不然找不到这个外部程序）。这个功能通常被用于转码，ffmpeg首先被当做client接收数据流，转码之后又被成为publisher来发布流。外部命令行中可以使用如下变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$name - stream name&lt;/li&gt;
&lt;li&gt;$app - application name&lt;/li&gt;
&lt;li&gt;$addr - client address&lt;/li&gt;
&lt;li&gt;$flashver - client flash version&lt;/li&gt;
&lt;li&gt;$swfurl - client swf url&lt;/li&gt;
&lt;li&gt;$tcurl - client tc url&lt;/li&gt;
&lt;li&gt;$pageurl - client page url&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Shell-style redirects can be specified in &lt;code&gt;exec_push&lt;/code&gt; directive for writing output and accepting input. Supported are&lt;/p&gt;

&lt;p&gt;可以在exec指令中定义Shell格式的转向符用于写输出和接收输入。支持如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;truncating output &lt;code&gt;&amp;gt;file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;appending output &lt;code&gt;&amp;gt;&amp;gt;file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;descriptor redirects like &lt;code&gt;1&amp;gt;&amp;amp;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;input &lt;code&gt;&amp;lt;file&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Make sure there&amp;rsquo;s no space between redirection character and stream name/number.
确保重定向符号和流名/号之间没有空格。&lt;/p&gt;

&lt;p&gt;You can specify full path to the command to execute or short command name. In the latter
case binary is looked up in directories specified by the &lt;code&gt;PATH&lt;/code&gt; environment variable.
By default nginx clears the environment which will usually make rtmp module run only binaries
located in standard directories like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/bin&lt;/code&gt;. To make this always work
please keep the original &lt;code&gt;PATH&lt;/code&gt; variable value with the following nginx directive.&lt;/p&gt;

&lt;p&gt;你可以在命令行写完整路径或只写命令名。如果是后者，会在PATH环境变量路径查找。 默认nginx会清理环境变量,rtmp模块会去/bin和/usr/bin查找可执行程序。请按下面命令设置PATH变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env PATH; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following ffmpeg call transcodes incoming stream to HLS-ready
stream (H264/AAC). FFmpeg should be compiled with libx264 &amp;amp; libfaac support
for this example to work.&lt;/p&gt;

&lt;p&gt;下面的ffmpeg指令将输入流转码成符合HLS编码要求的流(视频编码H264/音频编码AAC)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application src {
    live on;
    exec_push ffmpeg -i rtmp://localhost/src/$name -vcodec libx264 -vprofile baseline -g 10 -s 300x200 -acodec libfaac -ar 44100 -ac 1 -f flv rtmp://localhost/hls/$name 2&amp;gt;&amp;gt;/var/log/ffmpeg-$name.log;
}

application hls {
    live on;
    hls on;
    hls_path /tmp/hls;
    hls_fragment 15s;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这个最后的例子，就是有2个application,首先推流工具往第一个application &amp;lsquo;src&amp;rsquo;推原始流，原始流经过ffmpeg转码后推倒第二个application &amp;lsquo;hls&amp;rsquo;上去。&lt;/p&gt;

&lt;p&gt;另外我们也使用了这种方式进行转码。&lt;/p&gt;

&lt;h4 id=&#34;exec-pull:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_pull&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_pull command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed on play event.
The command is executed when first client connects to the stream and is
killed when the last one disconnects. This directive makes it possible
to pull remote stream in any format for local clients.&lt;/p&gt;

&lt;p&gt;当播放时执行提前指定的带参数的外部命令。外部程序在第一个客户端连接时开始执行，直到最后一个客户端断开连接时终止。这个参数使为本地客户端拉取任意格式的远程流成为可能。&lt;/p&gt;

&lt;p&gt;The feature works reliably only in single-worker mode. The reason for this
is we cannot make sure external process always connects to the right worker.
It will obviously connect to a random one. While this will still work in
most cases it&amp;rsquo;s not a recommended architecture, it will be unstable and buggy.&lt;/p&gt;

&lt;p&gt;此特性只在单worker模式下工作稳定。因为外部进程连接到随机的worker。虽然通常都能工作,但不推荐这么用(好坑爹)。&lt;/p&gt;

&lt;p&gt;Directive arguments are the same as for &lt;code&gt;exec_push&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;可以使用的变量和exec_push中提到的一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application myapp {
    live on;
    exec_pull ffmpeg -i http://example.com/video_$name.ts -c copy -f flv rtmp://localhost/$app/$name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above configuration &lt;code&gt;exec_pull&lt;/code&gt; directive serves all streams. That leads
to certain limitations on remote stream name format. It should be possible to construct
the remote url using available variables like &lt;code&gt;$app&lt;/code&gt;, &lt;code&gt;$name&lt;/code&gt; etc. When it&amp;rsquo;s not possible
you can add &lt;code&gt;exec_options on&lt;/code&gt; directive which permits setting additional stream options
in exec-family directives. The only option supported now is &lt;code&gt;name&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;上面的exec_pull配置服务所有流，这导致远程流的名称格式有一定的限制，也就是必须可以使用诸如$app $name等变量来构成其url。 你也可以使用exec_options on来许可额外的流选项，目前只支持name选项。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application myapp {
    live on;
    exec_options on;
    exec_pull ffmpeg -i http://example.com/tv1.ts -c copy -f flv rtmp://localhost/$app/$name name=mystream;
    exec_pull ffmpeg -i http://another.example.com/video_plus.ts -c copy -f flv rtmp://localhost/$app/$name name=anotherstream;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们目前没有用到exec_pull的场景，也没有做过多测试。&lt;/p&gt;

&lt;h4 id=&#34;exec-1:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; is an alias of &lt;code&gt;exec_push&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同exec_push&lt;/p&gt;

&lt;h4 id=&#34;exec-options:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_options&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_options on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;The directive toggles exec options mode. When activated you can
add exec-family directive options. The only exec option supported is &lt;code&gt;name&lt;/code&gt;.
This option makes it possible to apply exec only to specified stream.
Default if off.&lt;/p&gt;

&lt;p&gt;设置执行可选模式。你可以添加执行群可选方案。目前只支持name。此选项可以针对特定流执行。默认关。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec_options on;
# call on_publish only for &amp;quot;mystream&amp;quot;
exec_publish http://localhost/on_publish name=mystream;

# call on_play only for &amp;quot;another&amp;quot;
exec_play http://localhost/on_play name=another;

# execute different ffmpeg&#39;s for different streams
exec_pull http://example.com/abc.ts -c copy -f flv rtmp://localhost/$name/$app name=mystream;
exec_pull http://my.example.com/tele.ts -c copy -f flv rtmp://localhost/$name/$app name=tv;
exec_pull http://enother.example.com/hello/f.ts -c copy -f flv rtmp://localhost/$name/$app name=fun;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 默认关闭，我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-static:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_static&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_static command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Similar to &lt;code&gt;exec&lt;/code&gt; but runs specified command at nginx start.
Does not support substitutions since has no session context.&lt;/p&gt;

&lt;p&gt;类似exec,但是在启动nginx时运行,不支持变量替换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec_static ffmpeg -i http://example.com/video.ts -c copy -f flv rtmp://localhost/myapp/mystream;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-kill-signal:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_kill_signal&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_kill_signal signal&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets process termination signal. Default is kill (SIGKILL).
You can specify numeric or symbolic name (for POSIX.1-1990 signals).&lt;/p&gt;

&lt;p&gt;设置进程结束信号,默认SIGKILL,也可以设置数字或符号名。(POSIX.1-1990)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec_kill_signal term;
exec_kill_signal usr1;
exec_kill_signal 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;respawn:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;respawn&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;respawn on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;If turned on respawns child process when it&amp;rsquo;s terminated while publishing
is still on. Default is on;&lt;/p&gt;

&lt;p&gt;当发布进行时,子进程被终止会重启子进程，默认开启&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;respawn off;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;respawn-timeout:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;respawn_timeout&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;respawn_timeout timeout&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets respawn timeout to wait before starting new child instance.
Default is 5 seconds.&lt;/p&gt;

&lt;p&gt;设置重启新子进程的等待时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;respawn_timeout 10s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-publish:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_publish&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_publish command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed on
publish event. Return code is not analyzed. Substitutions of &lt;code&gt;exec&lt;/code&gt;
are supported here as well. In addition &lt;code&gt;args&lt;/code&gt; variable is supported
holding query string arguments.&lt;/p&gt;

&lt;p&gt;设置发布时执行外部命令带参数。不分析返回码。支持替换。另外参数支持查询字符串参数。&lt;br /&gt;
&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-play:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_play&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_play command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed on
play event. Return code is not analyzed. Substitution list
is the same as for &lt;code&gt;exec_publish&lt;/code&gt;.
设置播放时执行外部命令带参数。不分析返回码。替换列表同exec_publish。&lt;br /&gt;
&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-play-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_play_done&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_play_done command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed on
play_done event. Return code is not analyzed. Substitution list
is the same as for &lt;code&gt;exec_publish&lt;/code&gt;.
设置播放完调外部命令带参数。不分析返回码。替换列表同exec_publish。&lt;br /&gt;
&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-publish-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_publish_done&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_publish_done command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed on
publish_done event. Return code is not analyzed. Substitution list
is the same as for &lt;code&gt;exec_publish&lt;/code&gt;.
设置发布完时调用外部命令带参数。不分析返回码。替换列表同exec_publish。&lt;br /&gt;
&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个参数。&lt;/p&gt;

&lt;h4 id=&#34;exec-record-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;exec_record_done&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;exec_record_done command arg*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Specifies external command with arguments to be executed when
recording is finished. Substitution of &lt;code&gt;exec_publish&lt;/code&gt; are supported here
as well as additional variables&lt;/p&gt;

&lt;p&gt;设置录制完时执行外部命令。替换列表包含exec_publish的那些，同时支持额外的变量：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;recorder&lt;/code&gt; - recorder name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; - recorded file path (&lt;code&gt;/tmp/rec/mystream-1389499351.flv&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt; - path with directory omitted (&lt;code&gt;mystream-1389499351.flv&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;basename&lt;/code&gt; - file name with extension omitted (&lt;code&gt;mystream-1389499351&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dirname&lt;/code&gt; - directory path (&lt;code&gt;/tmp/rec&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Examples&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# track client info
exec_play bash -c &amp;quot;echo $addr $pageurl &amp;gt;&amp;gt; /tmp/clients&amp;quot;;
exec_publish bash -c &amp;quot;echo $addr $flashver &amp;gt;&amp;gt; /tmp/publishers&amp;quot;;

# convert recorded file to mp4 format
exec_record_done ffmpeg -y -i $path -acodec libmp3lame -ar 44100 -ac 1 -vcodec libx264 $dirname/$basename.mp4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 除了这个参数之前的exec_family的其他参数都是写在application{}配置块中，而这个是写在application{}下recorder{}配置块中的，它是针对recorder{}中定义的录制行为执行完之后触发的一个动作。&lt;/p&gt;

&lt;p&gt;比如我们可以在record结束之后触发ffmpeg从record到的文件中截图:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recorder rec {
    record keyframes;
    record_max_frames 4;
    record_path /tmp/snapshot;
    record_interval 30s;
    exec_record_done /usr/local/ffmpeg/2.8/bin/ffmpeg -i /tmp/snapshot/$name.flv -vframes 1 -an -f rawvideo -ss 00:00:00 -y -f image2 /tmp/snapshot/$name.jpg;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;live:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Live&lt;/h2&gt;

&lt;h4 id=&#34;live-1:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;live&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;live on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles live mode i.e. one-to-many broadcasting.&lt;/p&gt;

&lt;p&gt;开启直播功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;live on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;  无&lt;/p&gt;

&lt;h4 id=&#34;meta:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;meta&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;meta on|copy|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets metadata sending mode. The value of &lt;code&gt;on&lt;/code&gt; makes subscribers
receive reconstructed metadata packets containing predefined fields like
width, height etc. The value of &lt;code&gt;copy&lt;/code&gt; makes clients receive exact copy of
publisher metadata block including both standard and specific fields. The
value of &lt;code&gt;off&lt;/code&gt; turns off sending any RTMP metadata to subscribers.
Defaults to on.&lt;/p&gt;

&lt;p&gt;设置元数据发送方式。on:发送重组过的元数据给客户端，其中包含一些预定义的参数，如宽，高等。copy:元数据完全不变的发给客户端。off:不发送元数据给客户端。默认为on&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;meta copy;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;interleave:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;interleave&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;interleave on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles interleave mode. In this mode audio and video
data is transmitted on the same RTMP chunk stream.
Defaults to off.&lt;/p&gt;

&lt;p&gt;设置交错模式。如果打开，音视频数据会在同一个chunk流中传输。默认off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;interleave on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。如果要获得更好的音视频同步效果，可以试着打开。&lt;br /&gt;
参见 &lt;a href=&#34;https://github.com/arut/nginx-rtmp-module/issues/241&#34;&gt;nginx-rtmp-module issue 241&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;wait-key:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;wait_key&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;wait_key on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Makes video stream start with a key frame. Defaults to off.&lt;/p&gt;

&lt;p&gt;设置视频流从关键帧起播，默认off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wait_key on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 使用默认值，因为从关键帧起播会增加延迟。&lt;/p&gt;

&lt;h4 id=&#34;wait-video:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;wait_video&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;wait_video on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Disable audio until first video frame is sent. Defaults to off.
Can be combined with &lt;code&gt;wait_key&lt;/code&gt; to make client receive video
key frame with all other data following it. However this usually
increases connection delay. You can tune keyframe interval in your
encoder to reduce the delay.&lt;/p&gt;

&lt;p&gt;在发送视频帧之前不发音频数据。默认off。可以和wait_key配合使用，可以使客户端在收到视频关键帧后才收到随之而来的其他数据(而不是先收到音频数据，这时用户可以听到声音了，但画面还是黑的)。 这样玩通常会增加延迟，但是你可以通过调整编码器的关键帧间隔参数来减小延迟（比如使用ffmpeg的-g参数，就是用来调整关键帧间隔，也就是GOP长度的）。&lt;/p&gt;

&lt;p&gt;Recent versions of IE need this option to be enabled for normal playback.&lt;/p&gt;

&lt;p&gt;最近版本的IE需要打开这个参数才能正常播放。（不知是哪年的IE,现在应该没问题了，没测过，好久不用IE了。。。）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wait_video on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 使用默认值，我们不希望增加延迟。&lt;/p&gt;

&lt;h4 id=&#34;publish-notify:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;publish_notify&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;publish_notify on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Send &lt;code&gt;NetStream.Play.PublishNotify&lt;/code&gt; and &lt;code&gt;NetStream.Play.UnpublishNotify&lt;/code&gt; to
subscribers. Defaults to off.&lt;/p&gt;

&lt;p&gt;发送NetStream.Publish.Start和NetStream.Publish.Stop给用户。默认为off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;publish_notify on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h4 id=&#34;drop-idle-publisher:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;drop_idle_publisher&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;drop_idle_publisher timeout&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Drop publisher connection which has been idle (no audio/video data)
within specified time. Default is off. Note this only works when
connection is in publish mode (after sending &lt;code&gt;publish&lt;/code&gt; command).&lt;/p&gt;

&lt;p&gt;终止指定时间内闲置(没有音频/视频数据)的发布连接。默认为 off。注意这个仅仅对于发布模式的连接起作用(发送 publish 命令之后)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drop_idle_publisher 10s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置这个参数为20s,表示当一个发布连接上不发送任何数据到20s后就断掉这个连接。&lt;br /&gt;
参见 &lt;a href=&#34;https://github.com/arut/nginx-rtmp-module/issues/374&#34;&gt;nginx-rtmp-module issue 374&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;sync:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;sync&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;sync timeout&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Synchronize audio and video streams. If subscriber bandwidth
is not enough to receive data at publisher rate, some frames are
dropped by server. This leads to synchronization problem. When
timestamp difference exceeds the value specified as &lt;code&gt;sync&lt;/code&gt; argument an
absolute frame is sent fixing that. Default is 300ms.&lt;/p&gt;

&lt;p&gt;同步音频和视频流。如果用户带宽不足以以发布端的码率来接收数据，服务器会丢弃一些帧。这将导致同步问题。当时间戳差超过 sync 指定的值，将会发送一个绝对帧来解决这个问题。默认为 300 ms。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sync 10ms;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。但是隐隐感觉以后会用上 x_x&lt;/p&gt;

&lt;h4 id=&#34;play-restart:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;play_restart&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;play_restart on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;If enabled nginx-rtmp sends NetStream.Play.Start and NetStream.Play.Stop
to each subscriber every time publisher starts or stops publishing. If disabled
each subscriber receives those notifications only at the start and end of
playback. Default is off.&lt;/p&gt;

&lt;p&gt;使nginx-rtmp能够在发布启动或停止时发送 NetStream.Play.Start 和 NetStream.Play.Stop 到每个用户。如果关闭的话，那么每个用户就只能在回放的开始和结束时收到这些通知了。默认为 on。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;play_restart off;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;br /&gt;
参见 &lt;a href=&#34;https://github.com/arut/nginx-rtmp-module/issues/397&#34;&gt;nginx-rtmp-module issue 397&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;idle-streams:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;idle_streams&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;idle_streams on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;If disabled nginx-rtmp prevents subscribers from connecting to idle/nonexistent
live streams and disconnects all subscribers when stream publisher disconnects.
Default is on.&lt;/p&gt;

&lt;p&gt;当设置为off时，nginx-rtmp禁止客户端连接闲置(idle)或不存在(nonexistent)的直播流，并且在发布者连接断开后会把所有接收者连接也都断掉。默认是on。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;idle_streams off;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 用默认值就行，我们没有特殊设置。&lt;/p&gt;

&lt;h2 id=&#34;record:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Record&lt;/h2&gt;

&lt;h4 id=&#34;record-1:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record [off|all|audio|video|keyframes|manual]*&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Toggles record mode. Stream can be recorded in flv file. This directive
specifies what exactly should be recorded:&lt;/p&gt;

&lt;p&gt;切换录制模式。流可以被记录到 flv 文件。本指令指定应该被记录的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;off - no recording at all  啥也不录&lt;/li&gt;
&lt;li&gt;all - audio &amp;amp; video (everything) 啥都录&lt;/li&gt;
&lt;li&gt;audio - audio 音频&lt;/li&gt;
&lt;li&gt;video - video 视频&lt;/li&gt;
&lt;li&gt;keyframes - only key video frames 只录视频关键帧&lt;/li&gt;
&lt;li&gt;manual - never start recorder automatically, use control interface to start/stop 不自动启动录制，而是使用控制接口启动/停止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There can be any compatible combination of keys in a single record directive.&lt;br /&gt;
在单个记录指令中可以有任何兼容的组合键。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record all;

record audio keyframes;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; record{}配置中的参数都是实实在在的，可以测试观察到效果的，不像前面好多参数看完还特么云里雾里的。&lt;/p&gt;

&lt;p&gt;我们可以使用record指定只录制关键帧，然后用于生成截图，可以定期自动生成截图，也可以通过设置成manual，然后通过http control给nginx-rtmp发送命令来手工获取截图。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recorder snapshot {
    record keyframes manual;
    record_max_frames 1;
    record_path /tmp/snapshot;
    exec_record_done /usr/local/ffmpeg/2.8/bin/ffmpeg -i /tmp/snapshot/$name.flv -vframes 1 -an -f rawvideo -ss 00:00:00 -y -f image2 /tmp/snapshot/$name.jpg;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;record-path:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_path&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_path path&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Specifies record path to put recorded flv files to.&lt;br /&gt;
指定录制flv文件的路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_path /tmp/rec;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-suffix:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_suffix&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_suffix value&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Sets record file suffix. Defaults to &amp;lsquo;.flv&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_suffix _recorded.flv;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Record suffix can be a pattern in &lt;code&gt;strftime&lt;/code&gt; format.
The following directive&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_suffix -%d-%b-%y-%T.flv;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will produce files of the form &lt;code&gt;mystream-24-Apr-13-18:23:38.flv&lt;/code&gt;.
All supported &lt;code&gt;strftime&lt;/code&gt; format options can be found on
&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&#34;&gt;strftime man page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;设置录制文件名后缀,默认 flv。录制后缀可以是strftime格式。 如下格式生成类似-24- Apr-13-18:23:38.flv。 strftime格式可以从手册 &lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html&#34;&gt;strftime man page&lt;/a&gt; 找到&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-unique:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_unique&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_unique on|off&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;If turned on appends current timestamp to recorded files. Otherwise the same file
is re-written each time new recording takes place. Default is off.&lt;/p&gt;

&lt;p&gt;开启追加当前时间戳到录制文件中。否则同一个文件多次录制时会被覆盖。默认off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_unique on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-append:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_append&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_append on|off&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Toggles file append mode. When turned on recorder appends new data to the old file
or creates it when it&amp;rsquo;s missing. There&amp;rsquo;s no time gap between the old data and the new
data in file. Default is off.&lt;/p&gt;

&lt;p&gt;设置文件追加模式。如果打开，是将新录制的数据追加到已有文件的末尾或者没有就创建这个文件。在文件中新老数据之间没有间隔。默认off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_append on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-lock:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_lock&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_lock on|off&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;When turned on currently recorded file gets locked with &lt;code&gt;fcntl&lt;/code&gt; call.
That can be checked from elsewhere to find out which file is being recorded.
Default is off.&lt;/p&gt;

&lt;p&gt;开启时文件会被fcntl调用锁定，可以在其他地方发现哪个文件正在被录制。默认off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_lock on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On FreeBSD you can use &lt;code&gt;flock&lt;/code&gt; tool to check that. On Linux &lt;code&gt;flock&lt;/code&gt; and &lt;code&gt;fcntl&lt;/code&gt;
are unrelated so you are left with writing a simple script checking file lock status.
Here&amp;rsquo;s an example of such script &lt;code&gt;isunlocked.py&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在 FreeBSD 上你可以使用 flock 工具检查。在 Linux 上 flock 和 fcntl 无关，因此你需要去写一个简单的脚本来检查文件的锁定状态。以下 isunlocked.py 是一个这样的脚本的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python

import fcntl, sys

sys.stderr.close()
fcntl.lockf(open(sys.argv[1], &amp;quot;a&amp;quot;), fcntl.LOCK_EX|fcntl.LOCK_NB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 不知道什么情况下需要，用默认值就好。&lt;/p&gt;

&lt;h4 id=&#34;record-max-size:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_max_size&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_max_size size&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Set maximum recorded file size.&lt;/p&gt;

&lt;p&gt;设置录制文件最大值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_max_size 128K;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-max-frames:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_max_frames&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_max_frames nframes&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Sets maximum number of video frames per recorded file.&lt;/p&gt;

&lt;p&gt;设置每个录制文件的视频帧的最大数量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_max_frames 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-interval:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_interval&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_interval time&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Restart recording after this number of (milli)seconds.
Off by default. Zero means no delay between recordings. If
record_unique is off then all record fragments are written to the
same file. Otherwise timestamp is appended which makes files
differ (given record_interval is longer than 1 second).&lt;/p&gt;

&lt;p&gt;设置录制的间隔。默认off。如果设为0表示连续录制。同时，如果record_unique设为off的话，那每次录制都会写入同一个文件，而如果record_unique设为on时，每次录制都会生成一个以时间戳为后缀的新文件(间隔设置要大于1s)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;record_interval 1s;

record_interval 15m;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置，一般配合record_unique on一起使用。&lt;/p&gt;

&lt;h4 id=&#34;recorder:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;recorder&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;recorder name {...}&lt;/code&gt;&lt;br /&gt;
context: application&lt;/p&gt;

&lt;p&gt;Create recorder block. Multiple recorders can be created withing
single application. All the above mentioned recording-related
directives can be specified in &lt;code&gt;recorder{}&lt;/code&gt; block. All settings
are inherited from higher levels.&lt;/p&gt;

&lt;p&gt;创建录制配置块。一个application{}中可以创建多个recorder{}块，所有上边提到的指令都可以设置在recorder{}块里。继承高层次中的所有设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application {
    live on;

    # default recorder
    record all;
    record_path /var/rec;

    recorder audio {
        record audio;
        record_suffix .audio.flv;
    }

    recorder chunked {
        record all;
        record_interval 15s;
        record_path /var/rec/chunked;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;record-notify:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;record_notify&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;record_notify on|off&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Toggles sending NetStream.Record.Start and NetStream.Record.Stop
status messages (onStatus) to publisher when specific recorder
starts or stops recording file. Status description field holds
recorder name (empty for default recorder). Off by default.&lt;/p&gt;

&lt;p&gt;切换当定义录制启动或停止文件时发送 NetStream.Record.Start 和 NetStream.Record.Stop 状态信息(onStatus)到发布者。状态描述字段保存录制的名字(默认录制的话为空)。默认为 off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recorder myrec {
    record all manual;
    record_path /var/rec;
    record_notify on;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 目前没用到，用默认值。&lt;/p&gt;

&lt;h2 id=&#34;video-on-demand:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Video on demand&lt;/h2&gt;

&lt;h4 id=&#34;play:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;play&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;play dir|http://loc [dir|http://loc]*&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Play flv or mp4 file from specified directory or HTTP location.
If the argument is prefixed with &lt;code&gt;http://&lt;/code&gt; then it is assumed
that file should be downloaded from remote http location before
playing. Note playing is not started until the whole file is
downloaded. You can use local nginx to cache files on local machine.&lt;/p&gt;

&lt;p&gt;播放指定文件夹或HTTP路径上的FLV或MP4文件,http://表示下载播放远程地址的文件。 注意当整个文件下载完之后才会开始播放。你可以在本地使用nginx来缓存。&lt;/p&gt;

&lt;p&gt;Multiple play locations can be specified in a single &lt;code&gt;play&lt;/code&gt; directive.
When multiple &lt;code&gt;play&lt;/code&gt; directives are specified the location lists
are merged and inherited from higher scopes. An attempt to play
each location is made until a successful location is found.
If such location is not found error status is sent to client.&lt;/p&gt;

&lt;p&gt;同一个 play 指令可以定义多个播放地址。当多个 play 指令定义时，地址列表将被合并，并进行从更高域中继承。尝试播放每一个地址，直到发现一个成功的地址。如果没有找到成功地址，将发送错误状态到客户端。&lt;/p&gt;

&lt;p&gt;Indexed FLVs are played with random seek capability.
Unindexed FLVs are played with seek/pause disabled
(restart-only mode). Use FLV indexer (for example, yamdi)
for indexing.&lt;/p&gt;

&lt;p&gt;索引的 FLV 播放具有随机查找能力。没有索引的 FLV 则不具备查找/暂停能力(重播模式)。使用 FLV 索引器(比如 yamdi)来编索引。&lt;/p&gt;

&lt;p&gt;If you play FLVs recorded with the &lt;code&gt;record&lt;/code&gt; directive please do not
forget to index them before playing. They are created unindexed.&lt;/p&gt;

&lt;p&gt;record模块录制出来的flv文件是未经index处理的，如果你要想播放这些文件(随机拖动)，请别忘了自己index一下。&lt;/p&gt;

&lt;p&gt;Mp4 files can only be played if both video and audio codec are supported
by RTMP. The most common case is H264/AAC.&lt;/p&gt;

&lt;p&gt;mp4 文件只有在音频和视频编码都被 RTMP 支持时才可以播放。最常见的情况是 H264/AAC。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;application vod {
    play /var/flvs;
}

application vod_http {
    play http://myserver.com/vod;
}

application vod_mirror {
    # try local location first, then access remote location
    play /var/local_mirror http://myserver.com/vod;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Playing /var/flvs/dir/file.flv:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay rtmp://localhost/vod//dir/file.flv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two slashes after &lt;code&gt;vod&lt;/code&gt; make ffplay use &lt;code&gt;vod&lt;/code&gt; and application name
and the rest of the url as playpath.&lt;/p&gt;

&lt;p&gt;播放vod时，自己试试吧，可能需要在application名字后加两个反斜线才能播。&lt;/p&gt;

&lt;p&gt;栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Video on demand
application vod {
    play /tmp/Videos;
}

# Video on demand over HTTP
application vod_http {
    play http://localhost:8080/vod/;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将flv文件拷贝到/tmp/Videos目录下，&lt;br /&gt;
播放/tmp/Videos/test.flv  用 rtmp://localhost/vod/test.flv&lt;br /&gt;
播放/tmp/Videos/subfolder/test.flv的话用rtmp://localhost/vod//subfolder/test.flv&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; VOD是一个古老而现在又没什么卵用的模块，你喜欢就好。&lt;/p&gt;

&lt;h4 id=&#34;play-temp-path:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;play_temp_path&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;play_temp_path dir&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets location where remote VOD files are stored before playing.
Default is &lt;code&gt;/tmp&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;在播放之前设置远程存储的 VOD 文件路径。默认为 /tmp。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;play_temp_path /www;
play http://example.com/videos;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;play-local-path:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;play_local_path&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;play_local_path dir&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets location where remote VOD files copied from &lt;code&gt;play_temp_path&lt;/code&gt;
directory after they are completely downloaded. Empty value
disables the feature. By default it&amp;rsquo;s empty. The feature can be used
for caching remote files locally.&lt;/p&gt;

&lt;p&gt;This path should be on the same device as &lt;code&gt;play_temp_path&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;设置远程点播文件存储路径,从临时路径拷贝过来。空值的话禁用此功能。默认为空值。这个功能可以用于缓存远程文件在本地。&lt;br /&gt;
这一路径应该和 play_temp_path 处于同一设备。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# search file in /tmp/videos.
# if not found play from remote location
# and store in /tmp/videos

play_local_path /tmp/videos;
play /tmp/videos http://example.com/videos;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h2 id=&#34;relay:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Relay&lt;/h2&gt;

&lt;h4 id=&#34;pull:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;pull&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;pull url [key=value]*&lt;/code&gt;&lt;br /&gt;
Context: application&lt;/p&gt;

&lt;p&gt;Creates pull relay. Stream is pulled from remote machine
and becomes available locally. It only happens when at least
one player is playing the stream locally.&lt;/p&gt;

&lt;p&gt;创建 pull 中继。流将从远程服务器上拉下来，成为本地可用的。仅当至少有一个播放器正在播放本地流时发生。&lt;/p&gt;

&lt;p&gt;Url syntax: &lt;code&gt;[rtmp://]host[:port][/app[/playpath]]&lt;/code&gt;. If application
is missing then local application name is used. If playpath is missing
then current stream name is used instead.&lt;/p&gt;

&lt;p&gt;Url 语法：[rtmp://]host[:port][/app[/playpath]]。如果不指定 application 名字那么将会使用本地 application 名。如果不指定 playpath 那么就是用当前流的名字。&lt;/p&gt;

&lt;p&gt;The following parameters are supported:
* app - explicit application name 明确指定application名
* name - local stream name to bind relay to; if empty or non-specified then
all local streams within application are pulled 捆绑到 relay 的本地流名字。如果为空或者没有定义，那么将会使用 application 中的所有本地流。
* tcUrl - auto-constructed if empty  如果为空的话自动构建。
* pageUrl - page url to pretend 模拟页面 url。
* swfUrl - swf url to pretend 模拟 swf url。
* flashVer - flash version to pretend, default is &amp;lsquo;LNX.11,1,102,55&amp;rsquo; 模拟 flash 版本，默认为 &amp;lsquo;LNX.11,1,102,55&amp;rsquo;。
* playPath - remote play path 远程播放地址。
* live - toggles special behavior for live streaming, values: 0,1 切换直播特殊行为，值：0,1。
* start - start time in seconds 开始时间。
* stop - stop time in seconds 结束时间。
* static - makes pull static, such pull is created at nginx start 创建静态 pull，这样的 pull 在 nginx 启动时创建。&lt;/p&gt;

&lt;p&gt;If a value for a parameter contains spaces then you should use quotes around
the &lt;strong&gt;WHOLE&lt;/strong&gt; key=value pair like this : &lt;code&gt;&#39;pageUrl=FAKE PAGE URL&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;如果某参数的值包含空格，那么你应该在整个 key=value 对周围使用引号，比如：&lt;code&gt;&#39;pageUrl=FAKE PAGE URL&#39;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pull rtmp://cdn.example.com/main/ch?id=12563 name=channel_a;

pull rtmp://cdn2.example.com/another/a?b=1&amp;amp;c=d pageUrl=http://www.example.com/video.html swfUrl=http://www.example.com/player.swf live=1;

pull rtmp://cdn.example.com/main/ch?id=12563 name=channel_a static;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这组中继指令在nginx-rtmp组网时应该会用到，但是一直听说nginx-rtmp对于大规模组网支持的不够好，自己也没机会测试，以后如果有机会测试，会补上。&lt;/p&gt;

&lt;h4 id=&#34;push:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;push&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;push url [key=value]*&lt;/code&gt;&lt;br /&gt;
Context: application&lt;/p&gt;

&lt;p&gt;Push has the same syntax as pull. Unlike pull push directive publishes stream to remote server.&lt;/p&gt;

&lt;p&gt;push 的语法和 pull 一样。不同于 pull 指令的是 push 推送发布流到远程服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;push-reconnect:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;push_reconnect&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;push_reconnect time&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Timeout to wait before reconnecting pushed connection after disconnect. Default is 3 seconds.&lt;/p&gt;

&lt;p&gt;在断开连接后，在 push 重新连接前等待的时间。默认为 3 秒。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;push_reconnect 1s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;session-relay:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;session_relay&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;session_relay on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles session relay mode. In this mode relay is destroyed when connection is closed.
When the setting is off relay is destroyed when stream is closed so that another relay
could possibly be created later. Default is off.&lt;/p&gt;

&lt;p&gt;切换会话 relay 模式。在这种模式下连接关闭时 relay 销毁。当设置为 off 时，流关闭，relay 销毁，这样子以后另一个 relay 可以被创建。默认为 off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session_relay on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h2 id=&#34;notify:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Notify&lt;/h2&gt;

&lt;h4 id=&#34;on-connect:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_connect&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;on_connect url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server&lt;/p&gt;

&lt;p&gt;Sets HTTP connection callback. When clients issues connect command
an HTTP request is issued asynchronously and command processing is
suspended until it returns result code. If HTTP 2xx code is returned
then RTMP session continues. The code of 3xx makes RTMP redirect
to another application whose name is taken from &lt;code&gt;Location&lt;/code&gt; HTTP
response header. Otherwise connection is dropped.&lt;/p&gt;

&lt;p&gt;设置 HTTP 连接回调。当客户端发起一个连接命令时，一个 HTTP 请求异步发送，命令处理将被暂停,直到它返回结果代码。当 HTTP 2XX 码(成功状态码)返回时，RTMP 会话继续。返回码 3XX (重定向状态码)会使 RTMP 重定向到另一个从 HTTP 响应头的 &lt;code&gt;Location&lt;/code&gt; 里获取到的 application。否则(其他状态码)连接丢弃。&lt;/p&gt;

&lt;p&gt;Note this directive is not allowed in application scope since
application is still unknown at connection stage.&lt;/p&gt;

&lt;p&gt;注意这一指令在 application 域是不允许的，因为 application 在连接阶段还是未知的。&lt;/p&gt;

&lt;p&gt;HTTP request receives a number of arguments. POST method is used with
application/x-www-form-urlencoded MIME type. The following arguments are
passed to caller:&lt;/p&gt;

&lt;p&gt;HTTP 请求接收到一些参数。使用MIME的 application/x-www-form-urlencoded 编码方式的POST方法。以下参数将被传给调用者：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;call=connect&lt;/li&gt;
&lt;li&gt;addr - client IP address :客户端IP地址&lt;/li&gt;
&lt;li&gt;app - application name   :application的名字&lt;/li&gt;
&lt;li&gt;flashVer - client flash version  :客户端flash版本号&lt;/li&gt;
&lt;li&gt;swfUrl - client swf url :客户端swf url&lt;/li&gt;
&lt;li&gt;tcUrl - tcUrl             :客户端url&lt;/li&gt;
&lt;li&gt;pageUrl - client page url :客户端页面url&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to the above mentioned items all arguments passed explicitly to
connect command are also sent with the callback. You should distinguish
connect arguments from play/publish arguments. Players usually have a special
way of setting connection string separate from play/publish stream name.
As an example here&amp;rsquo;s how these arguments are set in JWPlayer&lt;/p&gt;

&lt;p&gt;除了上述参数以外，所有显式传递给连接命令的参数也由回调发送。你应该将连接参数和 play/publish 参数区分开。播放器常常有独特的方式设置连接字符串不同于 play/publish 流名字。这里是 JWPayer 是如何设置这些参数的一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
streamer: &amp;quot;rtmp://localhost/myapp?connarg1=a&amp;amp;connarg2=b&amp;quot;,
file: &amp;quot;mystream?strarg1=c&amp;amp;strarg2=d&amp;quot;,
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ffplay (with librtmp) example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ffplay &amp;quot;rtmp://localhost app=myapp?connarg1=a&amp;amp;connarg2=b playpath=mystream?strarg1=c&amp;amp;strarg2=d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usage example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_connect http://example.com/my_auth;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redirect example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /on_connect {
    if ($arg_flashver != &amp;quot;my_secret_flashver&amp;quot;) {
        rewrite ^.*$ fallback? permanent;
    }
    return 200;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 没用到这个，也没测试过，等需要用到再说。&lt;/p&gt;

&lt;h4 id=&#34;on-play:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_play&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;on_play url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets HTTP play callback. Each time a clients issues play command
an HTTP request is issued asynchronously and command processing is
suspended until it returns result code. HTTP result code is then
analyzed.&lt;/p&gt;

&lt;p&gt;设置 HTTP 播放回调。每次一个客户分发播放命令时，一个 HTTP 请求异步发送，命令处理会挂起 - 直到它返回结果码。之后再解析 HTTP 结果码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP 2xx code continues RTMP session&lt;/li&gt;
&lt;li&gt;HTTP 3xx redirects RTMP to another stream whose name is taken from
&lt;code&gt;Location&lt;/code&gt; HTTP response header. If new stream name is started with &lt;code&gt;rtmp://&lt;/code&gt;
then remote relay is created instead. Relays require that IP address is
specified instead of domain name and only work with nginx versions
greater than 1.3.10. See also &lt;code&gt;notify_relay_redirect&lt;/code&gt;.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise RTMP connection is dropped&lt;/p&gt;

&lt;p&gt;HTTP 2XX 返回码的话继续 RTMP 会话。&lt;br /&gt;
HTTP 3XX 返回码的话 重定向 RTMP 到另一个流，这个流的名字在 HTTP 返回头的 Location 获取。如果新流的名字起始于 rtmp:// 然后远程 relay 会被创建。relay 要求 IP 地址是指定的而不是域名，并且只工作在 1.3.10 版本以上的 nginx。另请参考 notify_relay_redirect。&lt;br /&gt;
其他返回码的话 RTMP 连接丢弃。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Redirect example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    ...
    location /local_redirect {
        rewrite ^.*$ newname? permanent;
    }
    location /remote_redirect {
        # no domain name here, only ip
        rewrite ^.*$ rtmp://192.168.1.123/someapp/somename? permanent;
    }
    ...
}

rtmp {
    ...
    application myapp1 {
        live on;
        # stream will be redirected to &#39;newname&#39;
        on_play http://localhost:8080/local_redirect;
    }
    application myapp2 {
        live on;
        # stream will be pulled from remote location
        # requires nginx &amp;gt;= 1.3.10
        on_play http://localhost:8080/remote_redirect;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTP request receives a number of arguments. POST method is used with
application/x-www-form-urlencoded MIME type. The following arguments are
passed to caller:
* call=play
* addr - client IP address
* clientid - nginx client id (displayed in log and stat)
* app - application name
* flashVer - client flash version
* swfUrl - client swf url
* tcUrl - tcUrl
* pageUrl - client page url
* name - stream name*&lt;/p&gt;

&lt;p&gt;这些参数和上一条一样。&lt;/p&gt;

&lt;p&gt;In addition to the above mentioned items all arguments passed explicitly to
play command are also sent with the callback. For example if stream is
accessed with the url &lt;code&gt;rtmp://localhost/app/movie?a=100&amp;amp;b=face&amp;amp;foo=bar&lt;/code&gt; then
&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; &amp;amp; &lt;code&gt;foo&lt;/code&gt; are also sent with callback.&lt;/p&gt;

&lt;p&gt;除了上述参数之外其他所有播放命令参数显式地发送回调。例如如果一个流由 url rtmp://localhost/app/movie?a=100&amp;amp;b=face&amp;amp;foo=bar 访问，然后呢 a,b 和 foo 发送回调。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_play http://example.com/my_callback;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们在on_play设置了回调。&lt;/p&gt;

&lt;h4 id=&#34;on-publish:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_publish&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;on_publish url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;The same as on_play above with the only difference that this directive sets
callback on publish command. Instead of remote pull push is performed in
this case.&lt;/p&gt;

&lt;p&gt;同上面提到的 on_play 一样，唯一的不同点在于这个指令在发布命令设置回调。不同于远程 pull，push 在这里是可以的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们在on_publish设置了回调。&lt;/p&gt;

&lt;h4 id=&#34;on-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_done&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;on_done url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets play/publish terminate callback. All the above applies here. However
HTTP status code is not checked for this callback.&lt;/p&gt;

&lt;p&gt;设置播放/发布禁止回调。上述所有适用于此。但这个回调并不检查 HTTP 状态码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个。&lt;/p&gt;

&lt;h4 id=&#34;on-play-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_play_done&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;on_play_done url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Same behavior as &lt;code&gt;on_done&lt;/code&gt; but only for play end event.&lt;/p&gt;

&lt;p&gt;等同于 on_done 的表现，但只适用于播放结束事件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个。&lt;/p&gt;

&lt;h4 id=&#34;on-publish-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_publish_done&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;on_publish_done url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Same behavior as &lt;code&gt;on_done&lt;/code&gt; but only for publish end event.&lt;/p&gt;

&lt;p&gt;等同于 on_done 的表现，但只适用于发布结束事件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们在on_publish_done设置了回调。&lt;/p&gt;

&lt;h4 id=&#34;on-record-done:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_record_done&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;on_record_done url&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Set record_done callback. In addition to common HTTP callback
variables it receives the following values
* recorder - recorder name in config or empty string for inline recorder
* path - recorded file path&lt;/p&gt;

&lt;p&gt;设置 record_done 回调。除了普通 HTTP 回调参数它还接受：recorder名字和录制文件路径这两个参数。&lt;/p&gt;

&lt;p&gt;Example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_record_done http://example.com/recorded;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个。&lt;/p&gt;

&lt;h4 id=&#34;on-update:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;on_update&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;on_update url&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Set update callback. This callback is called with period of
&lt;code&gt;notify_update_timeout&lt;/code&gt;. If a request returns HTTP result other
than 2xx connection is terminated. This can be used to synchronize
expired sessions. Two additional arguments &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;timestamp&lt;/code&gt;
are passed to this handler:
* &lt;code&gt;time&lt;/code&gt; is the number of seconds since play/publish call
* &lt;code&gt;timestamp&lt;/code&gt; is RTMP timestamp of the last audio/video packet sent to the client&lt;/p&gt;

&lt;p&gt;设置 update 回调。这个回调会在 notify_update_timeout 期间调用。如果一个请求返回结果不是 2XX，连接禁止。这可以用来同步过期的会话。追加 time 参数即播放/发布调用后的秒数会被发送给处理程序。&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;timestamp&lt;/code&gt; argument to individually limit playback duration
for each user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on_update http://example.com/update;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置了on_update回调。&lt;/p&gt;

&lt;h4 id=&#34;notify-update-timeout:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;notify_update_timeout&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;notify_update_timeout timeout&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets timeout between &lt;code&gt;on_update&lt;/code&gt; callbacks. Default is 30 seconds.&lt;/p&gt;

&lt;p&gt;在 on_update 回调之间的超时设置。默认为 30 秒。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;notify_update_timeout 10s;
on_update http://example.com/update;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置为1s。&lt;/p&gt;

&lt;h4 id=&#34;notify-update-strict:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;notify_update_strict&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;notify_update_strict on|off&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles strict mode for &lt;code&gt;on_update&lt;/code&gt; callbacks. Default is off.
When turned on all connection errors, timeouts as well as HTTP parse
errors and empty responses are treated as update failures and lead
to connection termination. When off only valid HTTP response codes
other that 2xx lead to failure.&lt;/p&gt;

&lt;p&gt;切换 on_update 回调严格模式。默认为 off。当设置为 on 时，所有连接错误，超时以及 HTTP 解析错误和空返回会被视为更新失败并导致连接终止。当设置为 off 时只有 HTTP 返回码不同于 2XX 时导致失败。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;notify_update_strict on;
on_update http://example.com/update;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个。&lt;/p&gt;

&lt;h4 id=&#34;notify-relay-redirect:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;notify_relay_redirect&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;notify_relay_redirect on|off&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Enables local stream redirect for &lt;code&gt;on_play&lt;/code&gt; and &lt;code&gt;on_publish&lt;/code&gt; remote
redirects. New stream name is MD5 hash of RTMP URL used for remote redirect.
Default is off.&lt;/p&gt;

&lt;p&gt;使本地流可以重定向为 on_play 和 on_publish 远程重定向。新的流名字是 RTMP URL 用于远程重定向。默认为 off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;notify_relay_redirect on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个。&lt;/p&gt;

&lt;h4 id=&#34;notify-method:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;notify_method&lt;/h4&gt;

&lt;p&gt;syntax: &lt;code&gt;notify_method get|post&lt;/code&gt;&lt;br /&gt;
context: rtmp, server, application, recorder&lt;/p&gt;

&lt;p&gt;Sets HTTP method for notifications. Default is POST with
&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; content type. In certain cases
GET is preferable, for example if you plan to handle the call
in &lt;code&gt;http{}&lt;/code&gt; section of nginx. In this case you can use &lt;code&gt;arg_*&lt;/code&gt; variables
to access arguments.&lt;/p&gt;

&lt;p&gt;设置 HTTP 方法通知。默认是带有 application/x-www-form-urlencoded 的 POST 内容类型。在一些情况下 GET 更好，例如如果你打算在 nginx 的 http{} 部分处理调用。在这种情况下你可以使用 arg_* 变量去访问参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;notify_method get;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With GET method handling notifications in &lt;code&gt;http{}&lt;/code&gt; section can be done this way&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /on_play {
    if ($arg_pageUrl ~* localhost) {
        return 200;
    }
    return 500;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有用到这个。&lt;/p&gt;

&lt;h2 id=&#34;hls:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;HLS&lt;/h2&gt;

&lt;h4 id=&#34;hls-1:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles HLS on the application.&lt;/p&gt;

&lt;p&gt;打开HLS直播功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls on;
hls_path /tmp/hls;
hls_fragment 15s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;http{}&lt;/code&gt; section set up the following location for clients to play HLS.&lt;/p&gt;

&lt;p&gt;为了开启HLS直播功能，要在nginx的http{}配置块进行如下配置：
主要是指定MIME类型；指定HLS分片存贮路径；缓存与否的控制；还有访问权限控制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    ...
    server {
        ...
        location /hls {
            types {
                application/vnd.apple.mpegurl m3u8;
            }
            root /tmp;
            add_header Cache-Control no-cache;

            # To avoid issues with cross-domain HTTP requests (e.g. during development)
            add_header Access-Control-Allow-Origin *;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 当然要开启，就是为了用这个功能！&lt;/p&gt;

&lt;h4 id=&#34;hls-path:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_path&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_path path&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets HLS playlist and fragment directory. If the directory does not
exist it will be created.&lt;/p&gt;

&lt;p&gt;设置 HLS 播放列表和分段目录。这一目录必须在 NGINX 启动前就已存在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据需要设置。&lt;/p&gt;

&lt;h4 id=&#34;hls-fragment:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_fragment&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_fragment time&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets HLS fragment length. Defaults to 5 seconds.&lt;/p&gt;

&lt;p&gt;设置HLS分段长度。默认为5秒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置为10秒。&lt;/p&gt;

&lt;h4 id=&#34;hls-playlist-length:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_playlist_length&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_playlist_length time&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets HLS playlist length. Defaults to 30 seconds.&lt;/p&gt;

&lt;p&gt;设置 HLS 播放列表长度。默认为 30 秒钟。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_playlist_length 10m;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置为10分钟，这样索引文件中只包含10分钟的分片信息。&lt;/p&gt;

&lt;h4 id=&#34;hls-sync:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_sync&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_sync time&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets HLS timestamp synchronization threshold. Default is 2ms.
This feature prevents crackling noises after conversion
from low-resolution RTMP (1KHz) to high-resolution MPEG-TS (90KHz).&lt;/p&gt;

&lt;p&gt;设置 HLS 时间戳同步阈值。默认为 2 ms。这一功能可以防止由低分辨率 RTMP (1KHz) 转换到高分辨率 MPEG-TS (90KHz) 之后出现噪音。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_sync 100ms;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们目前没有设置这个指令。&lt;/p&gt;

&lt;h4 id=&#34;hls-continuous:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_continuous&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_continuous on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles HLS continuous mode. In this mode HLS sequence number
is started from where it stopped last time. Old fragments are
keeped. Default is off.&lt;/p&gt;

&lt;p&gt;设置HLS连续模式。设成on时，每次往同一个application上推流时，切出来的新分片的序号是接着之前老分片的序号的。设成off时，分片序号每次都重新开始。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_continuous on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置为on。&lt;/p&gt;

&lt;h4 id=&#34;hls-nested:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_nested&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_nested on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles HLS nested mode. In this mode a subdirectory
of &lt;code&gt;hls_path&lt;/code&gt; is created for each stream. Playlist
and fragments are created in that subdirectory.
Default is off.&lt;/p&gt;

&lt;p&gt;设置 HLS 嵌套模式。这一模式下为每个流创建了一个 hls_path 的子目录。播放列表和分段在那个子目录中创建。默认为 off。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_nested on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们设置为on。&lt;/p&gt;

&lt;h4 id=&#34;hls-base-url:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_base_url&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_base_url url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets base url for HLS playlist items. When empty those
items have no prefix and assumed to be at the same location
as parent playlist or one level lower when &lt;code&gt;hls_nested&lt;/code&gt; is
used. This feature applies both to master (variant) and slave
HLS playlists. It can let you download the playlist and play it
locally since it contains full references to child playlists or
fragments. Empty by default.&lt;/p&gt;

&lt;p&gt;设置索引文件中的分片的base url。不设置时，索引文件中分片位置就是单独的一个分片名字，当用这个指令设置一个base url后，索引文件中每个分片的名字前都会加上同样的前缀。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_base_url http://myserver.com/hls/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有设置base url，因为我们会自己生成需要的点播索引文件。&lt;/p&gt;

&lt;h4 id=&#34;hls-cleanup:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_cleanup&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_cleanup on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles HLS cleanup. By default the feature is on.
In this mode nginx cache manager process removes old
HLS fragments and playlists from HLS directory.&lt;/p&gt;

&lt;p&gt;设置是否删除老的分片。默认是on,删除。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_cleanup off;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 为了防止时间一长服务器硬盘被HLS分片挤爆，所以一定设置成on。&lt;/p&gt;

&lt;h4 id=&#34;hls-fragment-naming:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_fragment_naming&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_fragment_naming sequential|timestamp|system&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets fragment naming mode.
* sequential - use increasing integers
* timestamp - use stream timestamp
* system - use system time&lt;/p&gt;

&lt;p&gt;设置分片的命名方式，有三种命名方式：序列号，流时间戳，当前系统时间。&lt;/p&gt;

&lt;p&gt;Default is sequential. 默认使用序列号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_fragment_naming system;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 根据业务需要一般都是使用第三种命名方式，system。&lt;/p&gt;

&lt;h3 id=&#34;hls-fragment-naming-granularity:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_fragment_naming_granularity&lt;/h3&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_fragment_naming_granularity number&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets granularity for hls fragment ids. If above zero, changes ids
to divide the provided value. Default is zero.&lt;/p&gt;

&lt;p&gt;当分片命名方式设置为system时，再设置这个参数，比如设置成500，那所有分片的名字都是以500取整，不会出现其他零碎的时间值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# use system time rounded to 500ms as fragment names
hls_fragment_naming system;
hls_fragment_naming_granularity 500;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 感觉没什么卵用，没设置。&lt;/p&gt;

&lt;h4 id=&#34;hls-fragment-slicing:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_fragment_slicing&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_fragment_slicing plain|aligned&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets fragment slicing mode.
* plain - switch fragment when target duration is reached
* aligned - switch fragment when incoming timestamp is a multiple of fragment duration. This mode makes it possible to generate identical fragments on different nginx instances&lt;/p&gt;

&lt;p&gt;设置切片模式。plain:普通切法。aligned: 当传入的时间戳是分片周期的整数倍时分片。这种模式可以在不同nginx实例上切出一致的分片。&lt;/p&gt;

&lt;p&gt;Default is plain.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_fragment_slicing aligned;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 目前我们没有设置。&lt;/p&gt;

&lt;h4 id=&#34;hls-variant:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_variant&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_variant suffix [param*]&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Adds HLS variant entry. When suffix is matched on stream name
then variant playlist is created for the current stream with all
entries specified by &lt;code&gt;hls_variant&lt;/code&gt; directives in current application.
Stripped name without suffix is used as variant stream name. The original
stream is processed as usual.&lt;/p&gt;

&lt;p&gt;Optional parameters following the suffix are appended to &lt;code&gt;EXT-X-STREAM-INF&lt;/code&gt; in
m3u8 playlist. See HLS spec. 3.3.10. EXT-X-STREAM-INF for the full list of supported
parameters.&lt;/p&gt;

&lt;p&gt;增加HLS多码流入口。前缀匹配上流的名字,建立多码流。&lt;/p&gt;

&lt;p&gt;当前应用hls_variant命令, 去除名字前缀作为流名字使用。原始流按通常处理。 前缀后边的可选参数追加到 m3u8列表的&lt;code&gt;EXT-X-STREAM-INF&lt;/code&gt;后面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rtmp {
    server {
        listen 1935;

        application src {
            live on;

            exec ffmpeg -i rtmp://localhost/src/$name
              -c:a libfdk_aac -b:a 32k  -c:v libx264 -b:v 128K -f flv rtmp://localhost/hls/$name_low
              -c:a libfdk_aac -b:a 64k  -c:v libx264 -b:v 256k -f flv rtmp://localhost/hls/$name_mid
              -c:a libfdk_aac -b:a 128k -c:v libx264 -b:v 512K -f flv rtmp://localhost/hls/$name_hi;
        }

        application hls {
            live on;

            hls on;
            hls_path /tmp/hls;
            hls_nested on;

            hls_variant _low BANDWIDTH=160000;
            hls_variant _mid BANDWIDTH=320000;
            hls_variant _hi  BANDWIDTH=640000;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; src中ffmpeg转出多路码率的码流，然后传入hls中，通过hls_variant设置多码率，这样就会生成一个masterplaylist和每个码率一个自己的mediaplaylist。从而可以支持HLS多码率的功能。&lt;/p&gt;

&lt;h4 id=&#34;hls-type:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_type&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_type live|event&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets HLS playlist type specified in &lt;code&gt;X-PLAYLIST-TYPE&lt;/code&gt; playlist directive.
Live HLS stream is usually played from the current live position which is
several fragments to the end of playlist. Event HLS stream is always played
from the start of playlist. When in &lt;code&gt;event&lt;/code&gt; mode make sure playlist length
is enough for the whole event. Default is &lt;code&gt;live&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;用于设置在生成的索引文件中&lt;code&gt;X-PLAYLIST-TYPE&lt;/code&gt;显示的类型。&lt;/p&gt;

&lt;p&gt;LIVE : 流通常从索引文件中倒数几片开始播放。&lt;/p&gt;

&lt;p&gt;EVENT: 流从头播放（使用此种模式需确认playlist的长度够长）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_type event;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们一定是用live的。&lt;/p&gt;

&lt;h4 id=&#34;hls-keys:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_keys&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_keys on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Enables HLS encryption. AES-128 method is used to encrypt the whole HLS fragments.
Off by default.&lt;/p&gt;

&lt;p&gt;开启HLS加密。 AES-128方法加密整个切片。默认关&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_keys on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s the example configuration using the HLS encryption. This configuration
requires that nginx is built with &lt;code&gt;--with-http_ssl_module&lt;/code&gt; for https support.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...

http {
    ...
    server {
        listen 443 ssl;
        server_name example.com;

        ssl_certificate /var/ssl/example.com.cert;
        ssl_certificate_key /var/ssl/example.com.key;

        location /keys {
            root /tmp;
        }
    }

    server {
        listen 80;
        server_name example.com;

        location /hls {
            root /tmp;
        }
    }
}

rtmp {
    server {
        listen 1935;

        application myapp {
            live on;

            hls on;
            hls_path /tmp/hls;

            hls_keys on;
            hls_key_path /tmp/keys;
            hls_key_url https://example.com/keys/;
            hls_fragments_per_key 10;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 目前我们不支持切片加密，所以没设置这个。&lt;/p&gt;

&lt;h4 id=&#34;hls-key-path:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_key_path&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_key_path path&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets the directory where auto-generated HLS keys are saved.
Key files have &lt;code&gt;.key&lt;/code&gt; extension and pseudo-random 16-byte content
created with the OpenSSL &lt;code&gt;RAND_bytes()&lt;/code&gt; routine.
If the directory does not exist it&amp;rsquo;s created in runtime.
By default, &lt;code&gt;hls_path&lt;/code&gt; directory is used for key files.
Remember however you should normally restrict access to key files which
is easier when these files are stored separately from playlist and fragments.&lt;/p&gt;

&lt;p&gt;设置自动生成HLS秘钥存放路径。key文件后缀.key,内容16位伪随机数。路径不存在会自动建立。 默认,hls_path 目录用于key文件。记住把key放在不同于切片和索引的目录,限制访问。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_key_path /tmp/keys;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 目前我们不支持切片加密，所以没设置这个。&lt;/p&gt;

&lt;h4 id=&#34;hls-key-url:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_key_url&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_key_url url&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets url for HLS key file entries. When empty those
items have no prefix and keys are assumed to be at the same location
as the playlist. Empty by default.&lt;/p&gt;

&lt;p&gt;为HLS秘钥文件设置URL入口。为空时没有前缀,假定秘钥存放在索引路径。默认空。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_key_url https://myserver.com/keys/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example playlist entry with the above setting&lt;/p&gt;

&lt;p&gt;示例为如上设置的列表入口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#EXT-X-KEY:METHOD=AES-128,URI=&amp;quot;https://myserver.com/keys/337.key&amp;quot;,IV=0x00000000000000000000000000000151
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 目前我们不支持切片加密，所以没设置这个。&lt;/p&gt;

&lt;h4 id=&#34;hls-fragments-per-key:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;hls_fragments_per_key&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;hls_fragments_per_key value&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets the number of HLS fragments encrypted with the same key.
Zero means only one key is created at the publish start
and all fragments within the session are encrypted with this key.
Default is zero.&lt;/p&gt;

&lt;p&gt;设置HLS切片用相同key加密的片数。0意味着发布时有1 个秘钥生成,会话所有的切片被此秘钥加密。默认为 0。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hls_fragments_per_key 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 目前我们不支持切片加密，所以没设置这个。&lt;/p&gt;

&lt;h2 id=&#34;mpeg-dash:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;MPEG-DASH&lt;/h2&gt;

&lt;h4 id=&#34;dash:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;dash&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;dash on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles MPEG-DASH on the application.
开始DASH直播功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dash on;
dash_path /tmp/dash;
dash_fragment 15s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;http{}&lt;/code&gt; section set up the following location for clients to play MPEG-DASH.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    ...
    server {
        ...
        location /dash {
            root /tmp;
            add_header Cache-Control no-cache;

            # To avoid issues with cross-domain HTTP requests (e.g. during development)
            add_header Access-Control-Allow-Origin *;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; DASH目前没有多少人在用，所以没有研究，但应该跟HLS也是差不多的。&lt;/p&gt;

&lt;h4 id=&#34;dash-path:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;dash_path&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;dash_path path&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets MPEG-DASH playlist and fragment directory. If the directory does not
exists it will be created.&lt;/p&gt;

&lt;p&gt;设置MPEG-DASH列表和切片路径。如果存在自动建立。&lt;/p&gt;

&lt;h4 id=&#34;dash-fragment:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;dash_fragment&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;dash_fragment time&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets MPEG-DASH fragment length. Defaults to 5 seconds.&lt;/p&gt;

&lt;p&gt;设置MPEG-DASH切片时 长。默认5s。&lt;/p&gt;

&lt;h4 id=&#34;dash-playlist-length:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;dash_playlist_length&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;dash_playlist_length time&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets MPEG-DASH playlist length. Defaults to 30 seconds.&lt;/p&gt;

&lt;p&gt;设置播放列表时长,默认30s。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dash_playlist_length 10m;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dash-nested:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;dash_nested&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;dash_nested on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles MPEG-DASH nested mode. In this mode a subdirectory
of &lt;code&gt;dash_path&lt;/code&gt; is created for each stream. Playlist
and fragments are created in that subdirectory.
Default is off.&lt;/p&gt;

&lt;p&gt;设置 MPEG-DASH 嵌套模式。这一模式下为每个流创建了一个 &lt;code&gt;dash_path&lt;/code&gt; 的子目录。播放列表和分段在那个子目录中创建。默认为 off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dash_nested on;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dash-cleanup:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;dash_cleanup&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;dash_cleanup on|off&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Toggles MPEG-DASH cleanup. By default the feature is on.
In this mode nginx cache manager process removes old
MPEG-DASH fragments and manifests from MPEG-DASH directory.
Init fragments are deleted after stream manifest is deleted.&lt;/p&gt;

&lt;p&gt;设置是否删除老的MPEG-DASH的分片。默认是删除。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dash_cleanup off;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;access-log:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Access log&lt;/h2&gt;

&lt;h4 id=&#34;access-log-1:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;access_log&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;access_log off|path [format_name]&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets access log parameters. Logging is turned on by default.
To turn it off use &lt;code&gt;access_log off&lt;/code&gt; directive. By default access logging
is done to the same file as HTTP access logger (&lt;code&gt;logs/access.log&lt;/code&gt;).
You can specify another log file path in &lt;code&gt;access_log&lt;/code&gt; directive.
Second argument is optional. It can be used to specify logging format by name.
See &lt;code&gt;log_format&lt;/code&gt; directive for more details about formats.&lt;/p&gt;

&lt;p&gt;设置Log相关参数。log默认是打开的，内容被输出到了nginx本身的logs/access.log中去了。我们可以通过设置把跟rtmp-module相关的输出到一个单独的log文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log_format new &#39;$remote_addr&#39;;
access_log logs/rtmp_access.log new;
access_log logs/rtmp_access.log;
access_log off;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; log_format可以定义Log的输出内容和格式，并把这个log形式组合起一个名字，比如上例的new, 然后在access_log就可以指定要输出的log位置，后边带上刚刚定义的log组合名字。&lt;/p&gt;

&lt;h4 id=&#34;log-format:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;log_format&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;log_format format_name format&lt;/code&gt;&lt;br /&gt;
Context: rtmp&lt;/p&gt;

&lt;p&gt;Creates named log format. Log formats look very much the same as nginx HTTP log
formats. Several variables are supported within log format:
* &lt;code&gt;connection&lt;/code&gt; - connection number
* &lt;code&gt;remote_addr&lt;/code&gt; - client address
* &lt;code&gt;app&lt;/code&gt; - application name
* &lt;code&gt;name&lt;/code&gt; - last stream name
* &lt;code&gt;args&lt;/code&gt; - last stream play/publish arguments
* &lt;code&gt;flashver&lt;/code&gt; - client flashVer
* &lt;code&gt;swfurl&lt;/code&gt; - client swfUrl
* &lt;code&gt;tcurl&lt;/code&gt; - client tcUrl
* &lt;code&gt;pageurl&lt;/code&gt; - client pageUrl
* &lt;code&gt;command&lt;/code&gt; - play/publish commands sent by client: &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;PLAY&lt;/code&gt;, &lt;code&gt;PUBLISH&lt;/code&gt;, &lt;code&gt;PLAY+PUBLISH&lt;/code&gt;
* &lt;code&gt;bytes_sent&lt;/code&gt; - number of bytes sent to client
* &lt;code&gt;bytes_received&lt;/code&gt; - number of bytes received from client
* &lt;code&gt;time_local&lt;/code&gt; - local time at the end of client connection
* &lt;code&gt;session_time&lt;/code&gt; - connection duration in seconds
* &lt;code&gt;session_readable_time&lt;/code&gt; - connection duration in human-readable format
* &lt;code&gt;msec&lt;/code&gt; - current unix timestamp in SEC.MSEC format&lt;/p&gt;

&lt;p&gt;上面是在定义log组合时可以用到的变量，自己可以自由组合。&lt;/p&gt;

&lt;p&gt;Default log format has the name &lt;code&gt;combined&lt;/code&gt;. Here&amp;rsquo;s the definition of this format&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$remote_addr [$time_local] $command &amp;quot;$app&amp;quot; &amp;quot;$name&amp;quot; &amp;quot;$args&amp;quot; - 
$bytes_received $bytes_sent &amp;quot;$pageurl&amp;quot; &amp;quot;$flashver&amp;quot; ($session_readable_time)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认输出的log组合是上边这些内容，命名为&lt;code&gt;combined&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们可以通过在application中指定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;access_log logs/rtmp_accesss.log combined;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将rtmp log输出到rtmp_access.log文件中。&lt;/p&gt;

&lt;h2 id=&#34;limits:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Limits&lt;/h2&gt;

&lt;h4 id=&#34;max-connections:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;max_connections&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;max_connections number&lt;/code&gt;&lt;br /&gt;
Context: rtmp, server, application&lt;/p&gt;

&lt;p&gt;Sets maximum number of connections for rtmp engine. Off by default.&lt;/p&gt;

&lt;p&gt;设置RTMP连接最大数。默认off&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;max_connections 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们没有设置限制。&lt;/p&gt;

&lt;h2 id=&#34;statistics:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Statistics&lt;/h2&gt;

&lt;p&gt;Statistics module is NGINX HTTP module unlike all other modules listed
here. Hence statistics directives should be located within http{} block.&lt;/p&gt;

&lt;p&gt;统计模块比较特殊，不是定义在rtmp{}中的，而是定义在http{}中，这个没有什么好说的，就按照下面那样配置就可以。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 但是。。。。这个模块有一个大坑，就是只能在nginx单worker的模式下正常工作，一旦设置为多worker模式，这个统计信息就完全不准了, 所以将来我们如果要做统计还要另想办法。&lt;/p&gt;

&lt;h4 id=&#34;rtmp-stat:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp_stat&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;rtmp_stat all&lt;/code&gt;&lt;br /&gt;
Context: http, server, location&lt;/p&gt;

&lt;p&gt;Sets RTMP statistics handler to the current HTTP location. RTMP statistics is
dynamic XML document. To watch this document in browser as XHTML page
use rtmp_stat_stylesheet directive.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    server {
        location /stat {
            rtmp_stat all;
            rtmp_stat_stylesheet stat.xsl;
        }
        location /stat.xsl {
            root /path/to/stat/xsl/file;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 其中/stat.xsl下指定的root路径下一定要有stat.xsl这模板文件，这个文件就在nginx-rtmp-module源码包的根目录下，拷贝过去就行了。&lt;/p&gt;

&lt;h4 id=&#34;rtmp-stat-stylesheet:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp_stat_stylesheet&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;rtmp_stat_stylesheet path&lt;/code&gt;&lt;br /&gt;
Context: http, server, location&lt;/p&gt;

&lt;p&gt;Adds XML stylesheet reference to statistics XML to make it viewable
in browser. See rtmp_stat description and example for more information.&lt;/p&gt;

&lt;h2 id=&#34;multi-worker-live-streaming:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Multi-worker live streaming&lt;/h2&gt;

&lt;p&gt;Multi-worker live streaming is implemented through pushing stream
to remaining nginx workers.&lt;/p&gt;

&lt;p&gt;多worker模式支持。通过推流给持续的nginx workers实现多worker直播流。&lt;/p&gt;

&lt;h4 id=&#34;rtmp-auto-push:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp_auto_push&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;rtmp_auto_push on|off&lt;/code&gt;&lt;br /&gt;
Context: root&lt;/p&gt;

&lt;p&gt;Toggles auto-push (multi-worker live streaming) mode.
Default is off.&lt;/p&gt;

&lt;p&gt;设置自动推模式(多worker 直播流)。默认关。设置为on时，开启支持多worker模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 我们会用多worker模式，所以我们把这项设为on&lt;/p&gt;

&lt;h4 id=&#34;rtmp-auto-push-reconnect:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp_auto_push_reconnect&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;rtmp_auto_push_reconnect timeout&lt;/code&gt;&lt;br /&gt;
Context: root&lt;/p&gt;

&lt;p&gt;Sets auto-push reconnect timeout when worker is killed.
Default is 100 milliseconds.&lt;/p&gt;

&lt;p&gt;设置worker被杀掉时自动重 连超时。默认100ms。&lt;/p&gt;

&lt;h4 id=&#34;rtmp-socket-dir:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp_socket_dir&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;rtmp_socket_dir dir&lt;/code&gt;&lt;br /&gt;
Context: root&lt;/p&gt;

&lt;p&gt;Sets directory for UNIX domains sockets used for stream pushing.
Default is &lt;code&gt;/tmp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;为推流设置UNIX域名 socket路径。默认是/tmp。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rtmp_auto_push on;
rtmp_auto_push_reconnect 1s;
rtmp_socket_dir /var/sock;

rtmp {
    server {
        listen 1935;
        application myapp {
            live on;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;control:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;Control&lt;/h2&gt;

&lt;p&gt;Control module is NGINX HTTP module and should be located within http{} block.&lt;/p&gt;

&lt;p&gt;控制模块是NGINX HTTP模块, 位于http{}配置块中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 这个模块和统计模块问题是一样的，只在单worker下能稳定正常工作，在多worker下就完蛋了，说这句话容易，但这都是自己踩过坑之后才知道的。&lt;/p&gt;

&lt;h4 id=&#34;rtmp-control:a8edd52e082f44f6a206bc3ba04c03d4&#34;&gt;rtmp_control&lt;/h4&gt;

&lt;p&gt;Syntax: &lt;code&gt;rtmp_control all&lt;/code&gt;&lt;br /&gt;
Context: http, server, location&lt;/p&gt;

&lt;p&gt;Sets RTMP control handler to the current HTTP location.&lt;/p&gt;

&lt;p&gt;为当前HTTP location设置RTMP控制器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
    server {
        location /control {
            rtmp_control all;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;Control-module&#34;&gt;More details about control module&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>first</title>
      <link>http://bingnan.github.io/blog/2015/12/20/first/</link>
      <pubDate>Sun, 20 Dec 2015 01:05:05 +0800</pubDate>
      
      <guid>http://bingnan.github.io/blog/2015/12/20/first/</guid>
      <description>&lt;p&gt;你好，世界！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>